EbFFA

This is just a bit of a lib that helps you play with music. It uses why's bloopsaphone to play sounds out of your speakers into your ears. I don't know where the sound goes to after that but I don't want to know that.

Note: I'm not a music expert or anything, I'm just going by what I do know.

So far, we have Notes and we have Intervals and we have Chords.

Notes are just notes, you know. They have a letter name like A or G, an octave, and perhaps an accidental. 21 constants are defined in ebffa.rb, one for each note. There are 12 distinct notes (semitones) in an octave, but it turns out there are 21 different names for these notes. Names like A, B, C, but also flats like Ab, Bb, Cb, and also sharps like As, Bs, and Cs. These are all defined for you and you can use them like this:

    irb> require 'ebffa'
      => true
    irb> C        # Note#inspect shows the note and its octave
      => note C4
    irb> C.va(2)  # Note#va changes the octave
      => note C2
    irb> Gs       # 's' means 'sharp'
      => note G#4
    irb> Bb.play  # Note#play plays the note through the bloopsaphone
      => nil

Intervals describe intervals between notes. 26 Interval constants are defined for you, ranging from perfect unison (P1) to augmented octave (A8). The Note class implements the + method which takes an interval and raises (or lowers) the note by that interval and returns it. Here are some examples.

    irb> P4
      => interval P4 A
    irb> Mn6.below
      => interval Mn6 B
    irb> C + P5
      => note G4
    irb> C + P5.below
      => note F3
    irb> C - P5
      => note F3
    irb> A + M3
      => note C#5
    irb> Fs + P8 + P8 + P8
      => note F#7

Chords are just arrays of Notes. Chord#play plays the notes all at once through the bloopsaphone, harmonically or melodically. A bunch of constructors are currently implemented for making triads and dominant seventh and diminished seventh chords. You can transpose a chord by adding or subtracting an Interval. You can invert a chord using Chord#invert or by passing the inversion of the chord you want as the last argument to a chord constructor (not Chord#new). Examples.

    irb> Chord.new([C, E, G, Bb])
      => chord C4, E4, G4, Bb4
    irb> Chord.new([C, E, G, Bb]).play
      => nil
    irb> Chord.new([C, E, G, Bb]).play(:melodic)
      => nil
    irb> Chord.triad(D)
      => chord D4, F#4, A4
    irb> Chord.triad(D, :min)
      => chord D4, F4, A4
    irb> Chord.triad(D, :maj, 1)   # D+ first inversion
      => chord F#4, A4, D5
    irb> Chord.triad(C, :dim)
      => chord C4, Eb4, Gb4
    irb> Chord.triad(C, :halfdim)
      => chord C4, E4, Gb4
    irb> Chord.v7(C)
      => chord G4, B4, D5, F5
    irb> Chord.o7(C)
      => chord B3, D4, F4, Ab4
    irb> Chord.o7(C, 3)            # third inversion
      => chord Ab4, B4, D5, F5
    irb> Chord.triad(D) + P5
      => chord A4, C#5, E5
